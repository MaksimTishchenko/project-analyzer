# Project Analyzer (Python)

Сервис для **статического анализа Python-проектов**, который по исходному коду строит
структурное представление проекта и визуализирует его архитектуру.

Проект ориентирован на **архитектурный анализ**, а не на выполнение кода.

---

## Возможности

Сервис анализирует Python-проект и возвращает:

* структуру проекта: `модули → классы → методы`, функции, импорты;
* **tech stack** (по импортам и dependency-файлам);
* **диаграмму классов** в формате **PlantUML** или **Mermaid**;
* REST API на **FastAPI** для анализа:

  * локальных проектов;
  * GitHub-репозиториев (опционально).

Анализ основан на **AST (Abstract Syntax Tree)** и не исполняет код проекта.

---

## Архитектура проекта (идеология)

Проект построен как **модульный пайплайн статического анализа**:

```
FileScanner
    ↓
CodeParser (AST)
    ↓
TechStackAnalyzer
    ↓
DiagramGenerator / DiagramAI
    ↓
FastAPI (REST)
```

### Ключевые принципы

* **Статический анализ** — код не выполняется.
* **Устойчивость** — ошибки в одном файле не ломают анализ всего проекта.
* **Безопасность** — доступ к файловой системе ограничен sandbox-директорией.
* **Модульность** — GitHub и LLM являются опциональными расширениями.

---

## Что реализовано

### 1) FileScanner

* Рекурсивное сканирование проекта.
* Игнор служебных директорий:
  `.git`, `__pycache__`, `.venv`, `node_modules`, `.idea`, и др.
* Опциональная поддержка **.gitignore**:

  * через `pathspec` (если установлен),
  * fallback-режим без зависимости.
* Пропуск:

  * бинарных файлов,
  * симлинков (по умолчанию),
  * слишком больших файлов (лимит).
* Результат:

  * список `.py` файлов,
  * dependency-файлы (`requirements.txt`, `pyproject.toml`, `setup.cfg`),
  * статистика сканирования.

---

### 2) CodeParser (AST)

* Парсинг Python-кода через `ast`.
* Извлекает:

  * классы и базовые классы (наследование),
  * методы и декораторы,
  * top-level функции (включая `async`),
  * импорты,
  * атрибуты (`self.x`, аннотации),
  * простые композиции/агрегации (по эвристикам).
* **Надёжность**:

  * `SyntaxError` или битый файл **не прерывают анализ**,
  * проблемный файл возвращается как пустой модуль с метаданными ошибки.

---

### 3) TechStackAnalyzer

* Определяет используемые технологии по:

  * импортам (AST),
  * `requirements.txt`,
  * `pyproject.toml` (Poetry).
* Возвращает структурированный JSON:

  * библиотеки и фреймворки,
  * категории,
  * сигналы,
  * эвристическую классификацию типа проекта
    (web / cli / ml / scientific).

---

### 4) DiagramGenerator

* Генерация диаграммы классов:

  * **PlantUML** или **Mermaid**.
* Поддержка:

  * наследования,
  * композиции / агрегации (если обнаружены),
  * ограничения количества классов (`diagram_max_classes`),
  * группировки по модулям.
* LLM-интеграция реализована как **опциональный слой** (fallback на статический генератор).

---

### 5) FastAPI API

Доступные эндпоинты:

* `GET /health`
* `POST /analyze/local`
* `POST /analyze/local/diagram`
* `POST /analyze/github`
* `POST /analyze/github/diagram`

---

## Безопасность локального анализа

Для защиты файловой системы используется **sandbox-директория**:

* параметр `analysis_root` в `app/settings.py`;
* анализ разрешён **только внутри этой директории**;
* попытка выхода за пределы → HTTP **403**.

Это позволяет безопасно использовать API даже при развёртывании в контейнере.

---

## Запуск (локально, без Docker)

### Требования

* Python **3.12**
* Poetry

Установка зависимостей:

```bash
poetry install
```

Запуск API:

```bash
poetry run uvicorn main:app --reload --port 8081
```

Swagger UI:

```
http://127.0.0.1:8081/docs
```

Тесты:

```bash
poetry run pytest
```

---

## Docker (рекомендуемый способ)

```bash
docker compose up --build
```

### Важно про пути

Если проект примонтирован, например, в `/workspace`:

```yaml
volumes:
  - ./:/workspace
```

То в API нужно передавать **путь внутри контейнера**:

```json
{
  "path": "/workspace"
}
```

---

## Пример запроса

### Полный анализ

`POST /analyze/local`

```json
{
  "path": "/workspace/mini_project",
  "include_tech_stack": true,
  "diagram_format": "plantuml",
  "diagram_max_classes": 25
}
```

### Только диаграмма

`POST /analyze/local/diagram`

Ответ — plain text:

* `text/vnd.plantuml` для PlantUML
* `text/markdown` для Mermaid

---

## Рекомендуемые параметры диаграммы

Чтобы диаграмма была читаемой:

* `diagram_max_classes`: `15–25`
* `diagram_public_only`: `true`
* `diagram_group_by_module`: `false`

---

## Структура проекта

```
app/
  file_scanner.py        # поиск файлов + статистика
  code_parser.py         # AST → ProjectModel
  tech_stack_analyzer.py # анализ зависимостей
  diagram_generator.py  # PlantUML
  diagram_generator_mermaid.py
  github_fetcher.py     # GitHub (опционально)
  service.py            # пайплайн анализа
  settings.py           # настройки / sandbox
main.py                 # FastAPI
tests/
```

---

## Итог

Проект демонстрирует:

* применение **AST-анализа** для исследования архитектуры;
* модульную архитектуру;
* устойчивость к ошибкам входных данных;
* базовые принципы безопасного API.

Он может использоваться как учебный пример статического анализа Python-кода
и как основа для дальнейшего развития (LLM-обработка, расширенные метрики, UI).
